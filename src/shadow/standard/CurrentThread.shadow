/**
 * Singleton {@code CurrentThread} provides methods which can be called on the current thread.
 * It also provides a way to access the actual {@code Thread} instance of this thread. 
 * 
 * @author Claude Abounegm
 * @seeDoc shadow:standard@Thread
 */

import shadow:io@Console;

singleton shadow:standard@
	CurrentThread
is CanIndex<int, Thread>
{
	[ImportNative]
	private readonly currentThread() => (Thread);

/*
	[ImportMethod]
	private readonly sleep(Thread instance, TimeSpan time) => ();
	[ImportMethod]
	private readonly sleep(Thread instance, int milliseconds) => ();
*/

	[ImportAssembly]
	private readonly __shadow_standard__CurrentThread_yield() => (boolean);
	
	/**
	* Gets the current thread's actual instance.
	*
	* @return The instance of the current thread.
	*/
	public readonly get instance() => (Thread)
	{
		return currentThread();
	}
	
	/**
	* Gets the Shadow-specific thread ID.
	*/
	public readonly get id() => (int)
	{
		return currentThread()->id;
	}
	
	/**
	* Gets the main thread, which is the root of all threads.
	*/
	public readonly get main() => (Thread)
	{
		return currentThread()->main;
	}
	
	/**
	* Gets the {@code Thread} which spawned this thread. The Main thread does not
	* have a parent, and is null.
	*/
	public readonly get parent() => (nullable Thread)
	{
		return currentThread()->parent;
	}

	/**
	* Gets the name of the thread set at spawn time. If no name is set
	* at spawn time, the name takes the format "Thread#{id}".
	*/
	public readonly get name() => (String)
	{
		return currentThread()->name;
	}
	
	/**
	* Requests this thread to be interrupted. If the thread is currently in the {@code WAITING} state, 
	* the thread is interrupted and the method that caused the thread to be in the {@code WAITING} state
	* raises an {@code InterruptedException}. The methods which are interruptible are {@code join()}, 
	* {@code sleep()}, {@code send()}, {@code receive()}, and all their overloads.
	* If the thread is not in the {@code WAITING} state, an interrupt flag is set, and the thread is interrupted
	* as soon as one of the above interruptible methods above are called, or when the user calls 
	* {@code CurrentThread.throwIfInterrupting()}, or throws an exception using {@code CurrentThread->interrupting}.
	*/
	public interrupt() => ()
	{
		currentThread().interrupt();
	}
	
	/**
	* Suspends the current running thread for the specified amount of time.
	* 
	* @param timeout The amount of time to pause this thread for.
	*/
	public readonly sleep(TimeSpan timeout) => ()
	{


		sleep(currentThread(), timeout);
	}
	
	/**
	* Suspends the current running thread for {@code milliseconds} milliseconds.
	* 
	* @param millisecondsTimeout The milliseconds to pause this thread for.
	*/
	public readonly sleep(int millisecondsTimeout) => ()
	{
	    Console.printLine("Sleep on CurrentThread!");
		sleep(currentThread(), millisecondsTimeout);
	}
	
	/**
	* Gets the n-th child that this thread spawned. This is NOT the Shadow-specific {@code Thread->id}.
	* If the thread has four children, this method could be used to retrieve the n-th child, for example
	* the third child (thus, its index is 2).
	* @param index the index of the child in the range [0, childrenCount).
	*/
	public readonly childAt(int index) => (Thread)
	{
		return currentThread().childAt(index);
	}
	
	/**
	* Gets the n-th child that this thread spawned. This is NOT the Shadow-specific {@code Thread->id}.
	* If the thread has four children, this method could be used to retrieve the n-th child, for example
	* the third child (thus, its index is 2).
	* @param index the index of the child in the range [0, childrenCount).
	*/
	public readonly index(int index) => (Thread)
	{
		return currentThread()[index];
	}
	
	/**
	* Gets the children of this thread, and if {@code recurse} is true, this method
	* will also traverse the children of the children recursively, until all children
	* have been visited.
	* Care should be taken using this function, as enumerating can throw an exception
	* if the children have changed.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children(boolean recurse) => (CanIterate<Thread>)
	{
		return currentThread().children(recurse);
	}
	
	/**
	* Gets the children of this thread. This method only enumerates through the first generation
	* children of this thread. i.e. only the thread that this thread spawned.
	*
	* @return {@code CanIterate<Thread>} An iterable class to be used with a foreach loop.
	*/
	public readonly children() => (CanIterate<Thread>)
	{
		return currentThread().children();
	}
	
	/**
	* Checks whether the {@code thread} is the same as the current thread.
	* This is equivalent to {@code thread->isCurrentThread}, but with null checking as well.
	*
	* @param other The thread to equate against the current thread.
	*
	* @return {@code true} if the other thread is not null and is the current thread; otherwise, {@code false}.
	*/
	public readonly equal(nullable Thread other) => (boolean)
	{
		return (other === currentThread());
	}
	
	/**
	* Gets the number of children the thread currently has. This method should be used with caution
	* even though it is thread safe. Since a thread can spawn threads at any time, this count can
	* drastically change between each call.
	*/
	public readonly get childrenCount() => (int)
	{
		return currentThread()->childrenCount;
	}
	
	/**
	* Causes the current thread to yield execution to another thread.
	*
	* @return {@code true} if the yield was successful; otherwise, {@code false}.
	*/
	public readonly yield() => (boolean)
	{
		return __shadow_standard__CurrentThread_yield();
	}
	
	/**
	* Returns a string with the format: "Thread ({Thread->name}): {Thread->stateStr}".
	*/
	public readonly toString() => (String)
	{
		return #currentThread();
	}
}