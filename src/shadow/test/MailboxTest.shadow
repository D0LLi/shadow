import shadow:io@Console;

class shadow:test@MailboxTest
{
    [ImportNative]
	private readonly initMailbox(int count) => ();

	[ImportNative]
	private readonly get staticMailbox() => (Mailbox);
	
	public main(String[] args) => ()
	{
		// mailbox is blocking, and for testing purposes,
		// can only take up to 10 elements.
		initMailbox(10);
		var mailbox = this->staticMailbox;

		// !!!! TEST #1 !!!!
		Console.printLine("Test1");
		var t1 = spawn(Test1Runner:());
		
		// we wait till the children get spawned:()
		while(t1->childrenCount != 4) {}
		foreach(var t in t1.children()) {
			t.join();
		}
		
		// send a stop signal
		mailbox.sendTo("stop");
		// send an invalid signal to make sure that exceptions
		// work correctly.
		mailbox.sendTo("wrong");
		
		try {
			t1.join();
		} catch(ThreadException e) {
			Console.printErrorLine(e->actual);
		}
		// !!!! TEST #1 !!!!
		
		// !!!! TEST #2 !!!!
		Console.printLine("Test2");
		Console.printLine(cast<String>(mailbox.receiveFirstFrom(String:class, CurrentThread->main)) == "wrong");

		var t2 = spawn(Test2Runner:());
		// !!!! TEST #2 !!!!
	}
	
	private class Test1Runner is CanRun
	{
		private class SenderRunner is CanRun
		{
			public run() => ()
			{
				var mailbox = staticMailbox();
				CurrentThread.sleep(CurrentThread->id * 100);
				
				mailbox.sendTo("hello");
				mailbox.sendTo(" ");
				mailbox.sendTo("world");
				mailbox.sendTo("!");
				mailbox.sendTo("\n");
			}
		}

		public run() => ()
		{
			nullable var threads = Thread:null[4];
			
			for (int i = 0; i < threads->size; i += 1) {
				threads[i] = spawn(SenderRunner:());
			}
			
			var mailbox = staticMailbox();
			
			var message = "";
			nullable Thread thread = null;
			
			while(message != "stop") {
				(var tempStr, var tempThread) = mailbox.receiveFirst(String:class);
				if(thread !== tempThread) {
					thread = tempThread;
					Console.print(tempThread->name # ": ");
				}
				
				message = cast<String>(tempStr);
				Console.print(message);
			}
			Console.printLine();
			
			try {
			(var a, var b) = mailbox.receiveFirst(int:class);
			Console.printLine(a # " " # b);
			} catch(Exception e) {
				Console.printLine("test");
			}
		}
	}
	
	private class Test2Runner is CanRun
	{		
		private class SenderRunner2<T> is CanRun
		{
			int secretNumber;
			public create(T i) {
				secretNumber = cast<int>(i);
			}
 			
			public run() => ()
			{
				var mailbox = staticMailbox();
				
				var x = int:create[5];
				for(int i = 0; i < x->size; i += 1) {
					x[i] = i;
					if(secretNumber == 1) {
						x[i] += 10;
					}
				}
				
				mailbox.sendTo("A string from " # CurrentThread->name);
				mailbox.sendTo("Secret number: ");
				mailbox.sendTo(secretNumber);
				mailbox.sendTo(x);
				x[0] = 55;
				mailbox.sendTo("done");
			}
		}

		private receiveAndPrint(Mailbox mailbox, int index, Class c, boolean lf) => (Object) {
			var o = mailbox.receiveFirstFrom(c, CurrentThread[index]);
			Console.print(o);
			if(lf) {
				Console.print("\n");
			}
			
			return o;
		}
		
		public run() => ()
		{
			for (int i = 0; i < 2; i += 1) {
				Console.printLine(spawn(SenderRunner2<int>:(i))->name);
			}
			
			var mailbox = staticMailbox();
			
			for (int i = 0; i < CurrentThread->childrenCount; i += 1) {
				receiveAndPrint(mailbox, i, String:class, true);
				receiveAndPrint(mailbox, i, String:class, false);
				receiveAndPrint(mailbox, i, int:class, true);
				var arr = receiveAndPrint(mailbox, i, Array<int>:class, true);
				receiveAndPrint(mailbox, i, String:class, true);
				Console.printLine(arr);
			}
		}
	}
	
	private createMailboxNative(int count) => (Mailbox)
	{
		return Mailbox:create(/*CurrentThread->instance,*/ count);
	}
}