import shadow:utility;

/**
 * Class {@code Signaler} contains signaling methods to communicate between threads
 * such as: waitForNotify(), waitForTimeout(), notify(), and notifyAll().
 *
 * @author Claude Abounegm
 *
 * @seeDoc shadow:test@SignalerTest
 * @seeDoc shadow:standard@Thread
 */
locked class shadow:natives@
	Signaler
{
    [ImportAssembly]
	private readonly __shadow_natives__Signaler_initialize() => (Pointer);
	[ImportAssembly]
	private readonly __shadow_natives__Signaler_destroy(Pointer handle) => (boolean);
	[ImportAssembly]
	private readonly __shadow_natives__Signaler_wait(Pointer handle) => (boolean);
	[ImportAssembly]
	private readonly __shadow_natives__Signaler_waitTimeout(Pointer handle, long timeEpochNow, long timeout) => (boolean);
	[ImportAssembly]
	private readonly __shadow_natives__Signaler_broadcast(Pointer handle) => (boolean);
	
	/// This method sets the interruptToken of the current thread to accompany the {@code Thread.interrupt()} method.
	[ImportMethod]
	private readonly setInterruptToken(Thread instance, nullable SignalToken interruptToken) => ();
	
	boolean terminate = false;
	int waitingThreads = 0;
	
	Mutex mutex;
	Pointer handle;
	LinkedList<SignalToken> tokensQueue;
	
	/**
	* Initializes a new {@code Signaler} instance.
	*/
	public create()
	{
		handle = __shadow_natives__Signaler_initialize();
		if(!handle->isValid) {
			throw Exception:create("Failed to create the Signaler.");
		}
		
		mutex = Mutex:create();
		tokensQueue = LinkedList<SignalToken>:create();
	}
	
	/**
	* Gets the number of threads that are currently waiting on this Signaler.
	*/
	public readonly get waitingThreadsCount() => (int)
	{
		mutex.lock();
		var count = waitingThreads;
		mutex.unlock();
		
		return count;
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or interrupt(). 
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForNotify() => ()
	{
		handle.assertValid("Signaler");

		var token = SignalToken:create(this);

		mutex.lock();
		try {
			tokensQueue.addLast(token);
			waitingThreads += 1;
			
			setInterruptToken(CurrentThread->instance, token);
			while(token->shouldWait and !terminate) {
				mutex.unlock();
				__shadow_natives__Signaler_wait(handle);
				mutex.lock();
			}
			// if the wait was interrupted, the setInterruptToken throws
			// the InterruptedException as the interrupting flag is true.
			setInterruptToken(CurrentThread->instance, null);
		} finally {
			waitingThreads -= 1;
			mutex.unlock();
		}
	}
	
	private waitSleep(TimeSpan timeout, boolean sleepOnly) => (boolean)
	{
		handle.assertValid("Signaler");

		var token = SignalToken:create(this);

		boolean timedout = false;
		var now = Time.epochNow();
		mutex.lock();
		try {
			// we only add the token if we want to be able to wake this thread up later.
			// since we do not want any notify to wake that thread up, we do not add it to
			// the queue if we only want to sleep.
			if(!sleepOnly) {
				tokensQueue.addLast(token);
			}

			waitingThreads += 1;
			
			setInterruptToken(CurrentThread->instance, token);
			mutex.unlock();
			while(!timedout and token->shouldWait and !terminate) {
				timedout = __shadow_natives__Signaler_waitTimeout(handle, now->totalNanoSeconds, timeout->totalNanoSeconds);
			}
			mutex.lock();
			// if the wait was interrupted, the setInterruptToken throws
			// the InterruptedException as the interrupting flag is true.
			setInterruptToken(CurrentThread->instance, null);
		} finally {
			waitingThreads -= 1;
			if(token.invalidate() and !sleepOnly) {
				// waitForNotify timed-out, so we still need to remove the 
				// token from the queue. sleepOnly operations are not added
				// to queue, so we do not worry about that.
				tokensQueue.remove(token);
			}
			mutex.unlock();
		}

		return timedout;
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or for the specified amount of time elapsed.
	*
	* @param timeout The amount of time to wait before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public waitForNotify(TimeSpan timeout) => (boolean)
	{
		return waitSleep(timeout, false);
	}
	
	/**
	* Suspends the calling thread until another thread calls notify(),
	* notifyAll(), or for the specified amount of time elapsed.
	*
	* @param millisecondsTimeout The amount of time to wait, in milliseconds, before timing out.
	* @return {@code true} if the operation timed-out; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForNotify(int millisecondsTimeout) => (boolean)
	{		
		return waitSleep(Time.fromMilliSeconds(millisecondsTimeout), false);
	}
	
	/**
	* Suspends the calling thread for the specified amount of time.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/
	public waitForTimeout(TimeSpan timeout) => ()
	{
		waitSleep(timeout, true);
	}

	/**
	* Suspends the calling thread for the specified amount of time.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	* @throws InterruptedException if another thread requested to interrupt this thread.
	*/	
	public waitForTimeout(int millisecondsTimeout) => ()
	{
		waitSleep(Time.fromMilliSeconds(millisecondsTimeout), true);
	}
	
	/**
	* Wakes a thread up, if there is any. Signaler is FIFO, meaning the first thread that
	* went to sleep is the first that gets woken up.
	*
	* @return {@code true} if a thread was woken up; otherwise, {@code false}.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public notify() => (boolean) 
	{
		handle.assertValid("Signaler");
		
		mutex.lock();
		try {
			// we would like to assure having a more or less organised wake up pattern.
			// Thus, notify should wake the threads up in the order that they went to sleep in.
			// we dequeue the first token, and broadcast to wake up all threads. This wakes up all
			// the threads owned by this Signaler, but only one thread actually "really" wakes up. That is
			// due to the SignalToken still being blocking on all threads but the one we unlocked.
			if(!tokensQueue.isEmpty()) {
				return signal(tokensQueue.removeFirst());
			}
		} finally {
			mutex.unlock();
		}
		
		return false;
	}
	
	/**
	* Wakes up all the waiting threads, which were put to sleep using {@code waitForNotify()}.
	* Threads are woken up in the order they were put to sleep. Threads sleeping due to {@code waitForTimeout()}
	* are not woken up, and the only way to wake them up is either by freeing this Signaler or by waiting for them to timeout.
	*
	* @return the number of threads that were woken up.
	*
	* @throws FreedResourceException if this Signaler has been freed.
	*/
	public notifyAll() => (int)
	{
		handle.assertValid("Signaler");

		mutex.lock();
		int count = 0;
		try {
			while(!tokensQueue.isEmpty()) {
				if(signal(tokensQueue.removeFirst())) {
					count += 1;
				}
			}
		} finally {
			mutex.unlock();
		}
		
		return count;
	}
	
	/**
	* Frees the allocated resources of the Signaler. All waiting threads are
	* woken up before freeing the resources. This includes threads that were
	* put to sleep using the waitForTimeout() method. Calling {@code free()} more
	* than once has no effect. This method is not thread-safe and should only be called
	* from one thread.
	*/
	public free() => ()
	{
		if(handle->isValid) {
			// empties the queue and notifies the threads in the order
			// they were put to sleep in.
			notifyAll();
			
			// if there are any sleeping threads, then they aren't in the queue
			// so we set a global terminate flag, and broadcast to the rest of the threads.
			terminate = true;
			__shadow_natives__Signaler_broadcast(handle);
			
			// free the allocated memory
			__shadow_natives__Signaler_destroy(handle);
			handle.free();
			
			mutex.free();
		}
	}
	
	/// used when the token has already been retrieved and does not need to be deleted.
	private signal(SignalToken token) => (boolean)
	{
		if(token.invalidate()) {
			__shadow_natives__Signaler_broadcast(handle);
			return true;
		}
		
		return false;
	}
	
	// used by SignalToken.signal() method, which is called from outside, and thus
	// we should remove the token from the queue.
	[ExportMethod(exportedTo = SignalToken:class)]
	private signalFromSignalToken(SignalToken token) => ()
	{
		handle.assertValid("Signaler");
		
		mutex.lock();
		try {
			tokensQueue.remove(token);
			signal(token);
		} finally {
			mutex.unlock();
		}
	}
}