/**
 * Class {@code ArrayList<V>} stores a list of
 * elements of type {@code V}, implemented with a dynamic array as internal
 * storage.
 */
class shadow:utility@
	ArrayList<V>
is  List<V>
{
	/// Gets size of the list.
	locked get long sizeLong = 0;
	
	nullable V[] elements;
	long modifications = 0L;
	Equate<V> equater;
	
	public create()
	{
		this(10);
	}
	
	public create(long initialCapacity)
	{
		this(initialCapacity, DefaultEqualizer<V>:create());
	}
	
	public create(long initialCapacity, Equate<V> equater)
	{				
		this:elements = V:null[initialCapacity];	
		this:equater = equater;
	}
	
	public readonly get size() => (int)
	{
		return cast<int>(sizeLong);
	}
	
	/**
	 * Checks whether or not the list is empty.
	 * @return {@code true} if the list is empty
	 */
	public readonly isEmpty() => ( boolean )
	{
		return sizeLong == 0L;
	}
	
	/**
	 * Retrieves the element at the given index. Legal indexes are from 0
	 * to one less than the size of the list. This operation is constant
	 * time.   
	 * @param index location of element
	 * @return element
	 * @throws IndexOutOfBoundsException if an illegal index is specified
	 */
	public readonly index(long index) => (V element)
	{
		if( index < 0L or index >= sizeLong )
			throw IndexOutOfBoundsException:create();
		
		return check(elements[index]);		
	}
	
	/**
	 * Stores an element into the given index. Legal indexes are from 0
	 * to the size of the list.  If an element is stored into the index
	 * corresponding to the size of the list, the list's size will increase
	 * by one. This operation is linear time in the worst case.	  	   
	 * @param index location of element
	 * @param value value of element	 
	 * @throws IndexOutOfBoundsException if an illegal index is specified
	 */
	public index(long index, V value) => ()
	{
		if( index < 0L or index > sizeLong )
			throw IndexOutOfBoundsException:create();
			
		if( index == sizeLong )
		{
			if( sizeLong >= elements->sizeLong )
				grow();
			sizeLong += 1L;			
		}			

		elements[index] = value;	
		modifications += 1L;
	}
	
	// Doubles the size of the backing array.
	private grow() => ()
	{		
		nullable var temp = V:null[elements->sizeLong * 2L];
		for( long i = 0; i < elements->sizeLong; i += 1L )
			temp[i] = elements[i];
		elements = temp;	
	}

	/**
	 * Adds an element to the end of the list. This operation is constant
	 * time in the best case and amortized constant time in the worst case,
	 * which occurs when list storage is full and a linear-time array resize
	 * must be performed.	 
	 * @param value value of element
	 * @return list after the add
	 */
	public add(V value) => ( ArrayList<V> )
	{
		index( sizeLong, value );
		return this;
	}
	
	/**
	 * Removes all elements from the list. This operation is
	 * constant time.	 
	 * @return list after being cleared	 	   
	 */		
	public clear() => (ArrayList<V>)
	{
		sizeLong = 0L;
		modifications += 1L;
		return this;
	}
	
	/**
	 * Checks to see if the list contains a particular element.	   
	 * @param value element to search for
	 * @return {@code true} if present
	 */
	public readonly contains(V value) => (boolean found)
	{				
		return indexOf(value) != -1L;
	}
	
	/**
	 * Finds the first index where a particular element is present. If the
	 * element is not present, -1 will be returned. 	   
	 * @param value element to search for
	 * @return index of element or -1 if not found
	 */
	public readonly indexOf(V value) => (long index)
	{	
		for(long i = 0; i < sizeLong; i += 1L) {
			if(equater.equal(value, check(elements[i]))) {
				return i;
			}
		}

		return -1L;
	}
	
	/**
	 * Removes the element at the given index. This operation is linear time
	 * in the worst case.
	 * @param index index of element to remove
	 * @return element being removed
	 * @throws IndexOutOfBoundsException if an illegal index is specified
	 */
	public delete(long index) => (V value)
	{
		if(index < 0L or index >= sizeLong)
			throw IndexOutOfBoundsException:create();

		V temp = check(elements[index]);
		for(long i = index; i < sizeLong - 1L; i += 1L)
			elements[i] = elements[i + 1];
		sizeLong -= 1L;
		modifications += 1L;
		return temp;
	}
	
	/**
	 * Removes the first occurrence of an element. This operation is linear
	 * time in the worst case.
	 * @param value value of element to remoe
	 * @return {@code true} if the element was found and removed	 
	 */	
	public remove(V value) => (boolean success)
	{
		long index = indexOf(value);
		if(index == -1L)
			return false;

		delete(index);
		return true;
	}
	
	/**
	 * Produces a {@code String} representation of the list, listing all
	 * elements in order.
	 * @return {@code String} representation 
	 */
	public readonly toString() => (String)
	{
		MutableString string = MutableString:create("[");
		boolean first = true;
		foreach(V value in this) {
			if(first)
				first = false;
			else
				string.append(", ");
			
			string.append(#value);
		}
		
		return string.append("]").toString();
	}

	/**
	 * Creates an iterator to iterate over all the values in the list.	   
	 * @return iterator
	 */
	public readonly iterator() => (Iterator<V>)
	{
		return ArrayListIterator<V>:create(this);
	}
	
	/*
	 * Simple iterator class uses a single index to keep track of the current
	 * location in the list.
	 */
	private class ArrayListIterator<V> is Iterator<V>
	{
		long index = 0L;
		immutable long expectedModifications;
		ArrayList<V> arrayList;
		
		public create(ArrayList<V> arrayList)
		{
			this:arrayList = arrayList;
			expectedModifications = arrayList:modifications;
		}
		
		private readonly checkForModifications() => ()
		{
			if(expectedModifications != arrayList:modifications)
				throw IllegalModificationException:create();		
		}
	
		public readonly hasNext() => (boolean)
		{
			checkForModifications();
			return index < arrayList:sizeLong;
		}
		
		public next() => (V)
		{
			checkForModifications();
			if( index >= arrayList:sizeLong )
				throw IndexOutOfBoundsException:create();

			V temp = check(arrayList:elements[index]);
			index += 1L;
			return temp;
		}
	}
}